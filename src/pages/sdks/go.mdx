import { Tag } from '@/components/Tag'
import { DocActions } from '@/components/DocActions'

export const description =
  'SDK to integrate Phase in server-side applications running Go.'

export const sections = [
  { title: 'Install', id: 'install-the-sdk' },
  { title: 'Import', id: 'import-the-sdk' },
  { title: 'Initialize', id: 'initialize-the-sdk' },
  { title: 'Usage', id: 'usage' },
]

<Tag variant="small">RESOURCES</Tag>

# Go SDK

SDK to integrate Phase in server-side applications running Go.

<DocActions />

- [github.com/phasehq/golang-sdk](https://github.com/phasehq/golang-sdk)

## Prerequisites

- Have signed up for the [Phase Console](https://console.phase.dev) and created an App
- Get a [`PHASE_SERVICE_TOKEN`](/access-control/authentication/tokens#creating-a-service-account-token)

---

<Note>
  Starting from version `2.0.0`, the Phase Go SDK is a pure Go implementation and no longer requires `libsodium` or `CGO`.
</Note>

## Install the SDK

Install the SDK using `go get`.

<CodeGroup title="Install">

    ```bash {{ title: 'Go Get' }}
    go get github.com/phasehq/golang-sdk/phase
    ```

</CodeGroup>

---

## Import the SDK

Import the SDK in your Go files to start using its features.

```go
import "github.com/phasehq/golang-sdk/phase"
```

---

## Initialize the SDK

Before interacting with the Phase service, initialize the SDK with your service token and the host information.

Parameters:

- `token` type `string`: Your Phase Service Token (`pss_service:v1:...` or `pss_service:v2:...`) or User Token (`pss_user:v1:...`)
- `host` type `string`: The URL of the Phase Console instance. Defaults to `https://console.phase.dev` if empty.
- `debug` type `bool`: Setting to true will result in a higher level of log verbosity useful when debugging

```go
package main

import (
    "log"
    "github.com/phasehq/golang-sdk/phase"
)

func main() {
    token := "pss_service:v1:....."
    host := "https://console.phase.dev" // Adjust this for a self-hosted instance of Phase
    debug := false // For logging verbosity, disable in production

    p, err := phase.New(token, host, debug)
    if err != nil {
        log.Fatalf("Failed to initialize Phase client: %v", err)
    }
}
```

---

## Usage

<Note>
  Using the AppID ensures precise targeting of the intended application, especially in scenarios where multiple applications might share the same name.
</Note>

You can get the AppID by going to your application settings in the Phase Console, hovering over UUID under the App section and clicking the `Copy` button:

![hello world](/assets/images/console/settings/application-id.png)

### Creating Secrets

Define key-value pairs and specify the Environment, App name or ID, and path (optional) to create new Secrets.

Options:

```go
type CreateOptions struct {
    KeyValuePairs []phase.KeyValuePair
    EnvName       string
    AppName       string
    AppID         string
    Path          string
    OverrideValue string
}

type KeyValuePair struct {
    Key   string
    Value string
}
```

```go
err := p.Create(phase.CreateOptions{
    KeyValuePairs: []phase.KeyValuePair{
        {Key: "API_KEY", Value: "api_secret"},
        {Key: "DB_HOST", Value: "localhost:5432"},
    },
    EnvName: "Production",
    AppName: "MyApp",       // Or use AppID: "app-id-here"
    Path:    "/api/keys",   // Optional, default path: /
})
if err != nil {
    log.Fatalf("Failed to create secret: %v", err)
}
```

### Getting Secrets

Provide the Environment name, App name or ID, and optionally filter by specific keys, tags, and path.

Options:

```go
type GetOptions struct {
    EnvName  string
    AppName  string
    AppID    string
    Keys     []string // Optional: filter by specific key names
    Tag      string   // Optional: filter by tag
    Path     string   // Optional: filter by path (default: /)
    Dynamic  bool     // Optional: include dynamic secrets
    Lease    bool     // Optional: generate leases for dynamic secrets
    LeaseTTL *int     // Optional: lease TTL in seconds
}
```

Each secret is returned as a `SecretResult`:

```go
type SecretResult struct {
    Key          string
    Value        string
    Comment      string
    Path         string
    Application  string
    Environment  string
    Tags         []string
    Overridden   bool         // true if a personal override is active
    IsDynamic    bool         // true for dynamic secrets
    DynamicGroup string       // provider group label for dynamic secrets
}
```

#### Get all secrets

```go
secrets, err := p.Get(phase.GetOptions{
    EnvName: "Production",
    AppName: "MyApp", // Or use AppID: "app-id-here"
})
if err != nil {
    log.Fatalf("Failed to get secrets: %v", err)
}
for _, s := range secrets {
    log.Printf("%s=%s", s.Key, s.Value)
}
```

#### Get specific keys

```go
secrets, err := p.Get(phase.GetOptions{
    EnvName: "Production",
    AppName: "MyApp",
    Keys:    []string{"API_KEY", "DB_HOST"},
})
```

#### Filter by tag and path

```go
secrets, err := p.Get(phase.GetOptions{
    EnvName: "Production",
    AppName: "MyApp",
    Tag:     "backend",
    Path:    "/api/config",
})
```

#### Include dynamic secrets with leases

```go
secrets, err := p.Get(phase.GetOptions{
    EnvName: "Production",
    AppName: "MyApp",
    Dynamic: true,
    Lease:   true,
})
```

### Updating a Secret

Provide the new value along with the environment name, application name or ID, and key to update an existing secret.

Options:

```go
type UpdateOptions struct {
    EnvName         string
    AppName         string
    AppID           string
    Key             string
    Value           string
    SourcePath      string // Path where the secret currently lives
    DestinationPath string // Optional: move the secret to a new path
    Override        bool   // Set a personal override
    ToggleOverride  bool   // Toggle personal override on/off
}
```

```go
result, err := p.Update(phase.UpdateOptions{
    EnvName: "Production",
    AppName: "MyApp", // Or use AppID: "app-id-here"
    Key:     "API_KEY",
    Value:   "my_updated_api_secret",
})
if err != nil {
    log.Fatalf("Failed to update secret: %v", err)
}
```

### Deleting Secrets

Specify the environment name, application name or ID, keys to delete, and optionally the path.

Options:

```go
type DeleteOptions struct {
    EnvName      string
    AppName      string
    AppID        string
    KeysToDelete []string
    Path         string
}
```

```go
keysNotFound, err := p.Delete(phase.DeleteOptions{
    EnvName:      "Production",
    AppName:      "MyApp", // Or use AppID: "app-id-here"
    KeysToDelete: []string{"API_KEY", "OLD_SECRET"},
    Path:         "/api/keys", // Optional, default path: /
})
if err != nil {
    log.Fatalf("Failed to delete secret: %v", err)
}
if len(keysNotFound) > 0 {
    log.Printf("Keys not found: %v", keysNotFound)
}
```

### Resolving Secret References

Resolve `${REF}` syntax in secret values, including cross-environment and cross-application references.

```go
secrets, _ := p.Get(phase.GetOptions{
    EnvName: "Production",
    AppName: "MyApp",
})

for _, s := range secrets {
    resolved := phase.ResolveAllSecrets(s.Value, secrets, p, s.Application, s.Environment)
    fmt.Printf("%s=%s\n", s.Key, resolved)
}

// Clear the referencing cache between runs
phase.ResetSecretsCache()
```

### Overrides

Create or update a personal override for a secret:

```go
// Create a secret with an override value
err := p.Create(phase.CreateOptions{
    KeyValuePairs: []phase.KeyValuePair{
        {Key: "API_URL", Value: "https://api.example.com"},
    },
    EnvName:       "Development",
    AppName:       "MyApp",
    OverrideValue: "http://localhost:3000",
})

// Update override for existing secret
_, err := p.Update(phase.UpdateOptions{
    EnvName:  "Development",
    AppName:  "MyApp",
    Key:      "API_URL",
    Value:    "http://localhost:4000",
    Override: true,
})

// Toggle override on/off
_, err := p.Update(phase.UpdateOptions{
    EnvName:        "Development",
    AppName:        "MyApp",
    Key:            "API_URL",
    ToggleOverride: true,
})
```
