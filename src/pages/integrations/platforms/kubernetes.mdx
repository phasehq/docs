import { Tag } from '@/components/Tag'

export const description = 'Integrate Phase with Kubernetes'

<Tag variant="small">INTEGRATE</Tag>

# Kubernetes

You can use Phase run to inject secrets to your application process during runtime. There's no need for you to change any code or add a dependency.

## Prerequisites

- Have signed up for the [Phase Console](/quickstart) and created an application.
- A [`PHASE_SERVICE_TOKEN`](/console/tokens#service-tokens) for your application.

## Using Phase Kubernetes operator

![Phase Cryptography](/assets/phase-kubernetes-operator.svg)

### 1. Add

```fish
helm repo add phase https://helm.phase.dev && helm repo update
```

```fish
helm install phase-secrets-operator phase/phase-kubernetes-operator --set image.tag=v0.1.0
```

### 1. Create a service token secret in kubernetes

1. Base64 encode the Phase service token

Example:

```fish
λ echo -n 'pss_service:v1:a6720814be12945adac50c07cd5ff9d9e295cfecef24be90802028cec826fe24:cbc30f5058b73ef4533b0a293a0e2e3c21
b684dcf3385784d0d2bc637468141c:54b0d7c089fe560112d97ac4591a6a9ed800e6e57da463dc3e785719dc8fbdf8:6009b8986180132b7ef02197ea981
fa51732945f339b1af16a605d3b08793899' | base64 -w 0

cHNzX3NlcnZpY2U6djE6YTY3MjA4MTRiZTEyOTQ1YWRhYzUwYzA3Y2Q1ZmY5ZDllMjk1Y2ZlY2VmMjRiZTkwODAyMDI4Y2VjODI2ZmUyNDpjYmMzMGY1MDU4YjczZWY0NTMzYjBhMjkzYTBlMmUzYzIxYjY4NGRjZjMzODU3ODRkMGQyYmM2Mzc0NjgxNDFjOjU0YjBkN2MwODlmZTU2MDExMmQ5N2FjNDU5MWE2YTllZDgwMGU2ZTU3ZGE0NjNkYzNlNzg1NzE5ZGM4ZmJkZjg6NjAwOWI4OTg2MTgwMTMyYjdlZjAyMTk3ZWE5ODFmYTUxNzMyOTQ1ZjMzOWIxYWYxNmE2MDVkM2IwODc5Mzg5OQ==⏎
```

2. Paste the base64 encoded Phase service token in the `token` field

`service-token.yml`

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: phase-service-token
  namespace: default # You specify the desired namespace here.
type: Opaque
data:
  token: '<phase service token>' # Base64 Phase service token
```

3. Deploy the secret

```fish
kubectl apply -f service-token.yml
```

### 2. Deploy the Phase Kubernetes CR (custom resource)

`phase-cr.yaml`

```yaml
apiVersion: secrets.phase.dev/v1alpha1
kind: PhaseSecret
metadata:
  name: example-phase-secret
  namespace: default
spec:
  phaseAppEnv: 'prod ' # OPTIONAL - The Phase application environment to fetch secrets from
  phaseHost: 'https://console.phase.dev' # OPTIONAL - URL of a Phase Console instance
  authentication:
    serviceToken:
      serviceTokenSecretReference:
        secretName: 'phase-service-token' # Name of the Phase service token with access to your application
        secretNamespace: 'default'
  managedSecretReferences: # Managed secrets in Kubernetes that Phase will sync secrets with
    - secretName: 'my-application-secret' # Name of the managed secret in Kubernetes that will be consumed by your application
      secretNamespace: 'default'
```

## Using Init Container

You can easily integrate with your kubernetes workload and inject secrets securely using in memory init containers.

1. Create `PHASE_SERVICE_TOKEN` secret.

```fish
kubectl create secret generic phase-token --from-literal=PHASE_SERVICE_TOKEN=<YOUR_PHASE_SERVICE_TOKEN>
```

2. Create or edit your `docker-compose.yml`:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: alpine-pod
spec:
  volumes:
    - name: secrets-volume
      emptyDir:
        medium: Memory
  initContainers:
    - name: fetch-secrets
      image: phasehq/cli:latest
      volumeMounts:
        - name: secrets-volume
          mountPath: /secrets
      env:
        - name: PHASE_SERVICE_TOKEN
          valueFrom:
            secretKeyRef:
              name: phase-token
              key: PHASE_SERVICE_TOKEN
      command:
        - /bin/sh
        - -c
        - phase secrets export > /secrets/secrets.env
  containers:
    - name: alpine-main
      image: alpine:latest
      volumeMounts:
        - name: secrets-volume
          mountPath: /secrets
      command:
        - /bin/sh
        - -c
        - source /secrets/secrets.env && printenv
```

## Security Benefits

1. **Isolation of Responsibilities**: Init containers allow you to separate the responsibility of setting up the environment from the primary purpose of the main container. By using init containers solely to fetch secrets and populate in-memory volumes, you reduce the surface area for potential attacks targeted at the main application.

2. **Transient Nature**: By using in-memory volumes, the data doesn't persist beyond the lifecycle of the pod. When the pod is terminated, the data is lost. This reduces the risk of secret data being left behind.

3. **No Persistent Storage**: Since secrets fetched and placed in an in-memory volume aren't written to any persistent storage, there's no risk of them being exposed if the underlying storage is compromised or improperly decommissioned.

## Security Considerations

1. **In-Memory Exposure**: While the secrets are not persisted to disk, they are still available in the node's RAM. A process or user with sufficient privileges on the node could potentially access data directly from memory.

2. **Swap Space**: If the Kubernetes node is configured with swap, and the node starts swapping memory contents to disk, in-memory data (including secrets) might end up being written to swap space. It's recommended to disable swap on Kubernetes nodes for this (and other) reasons.

3. **Secret Versioning**: If you update a secret, the change won't be automatically propagated to running pods. The pods need to be restarted to pick up the new version of the secret.

<div className="not-prose">
  <Button
    href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
    variant="text"
    arrow="right"
    children="Kubernetes - Init Containers"
  />
</div>
