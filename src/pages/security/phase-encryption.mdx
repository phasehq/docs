import { Tag } from '@/components/Tag'

export const description =
  'Phase Cryptography is the architecture used to generate encryption keys, secure keys for storage / transmission over the network and perform encryption or decryption operations.'

<Tag variant="small">SECURITY</Tag>

# Phase Cryptography

Phase Cryptography is the architecture used to generate encryption keys, secure keys for storage / transmission over the network and perform encryption or decryption operations.
Keys are generated or derived in the Phase console client-side, and encrypted before being stored either on disk within your browser, or on our backend.
The [SDKs](/sdks) use this cryptographic architecture to encrypt and decrypt data in your applications.

![Phase Cryptography](/assets/phase-console-crypto.svg)

<div className="text-center italic">
  A high level view of the Phase Cryptography architecture
</div>

## Account keyring

Each Phase account is created with an Account Keyring on signup, which comprises an [`XChaCha-Poly1305`](https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305) symmetric key and an [`Ed25519`](https://www.cryptopp.com/wiki/Ed25519) signing keypair.

An Account Keyring is generated as follows:

### 1. Account Recovery phrase

The Account Recovery phrase allows you to derive your Account Keyring securely when logging in on a new device or browser.

A **24-word mnemonic** phrase is generated using the [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) Bitcoin spec.

<Note>
  The native BIP39 implementations use `PBKDF2` with `SHA512` with 2048
  iterations for key derivation, which for our use case does not provide
  sufficient protection. We instead use a two-staged key derivation process
  where we only use BIP39 for recovery phrase generation and use libsodium's
  implementation of [Argon2ID
  1.3](https://doc.libsodium.org/password_hashing#argon2) for key derivation.
</Note>

### 2. Account Seed

The Account Seed is the root source of entropy used to derive all keys in the Account Keyring.

The **24 Word Account Recovery** is securely hashed with [`Argon2ID`](https://en.wikipedia.org/wiki/Argon2) using libsodium's `crypto_pwhash` and the following parameters:

- `crypto_pwhash_OPSLIMIT_SENSITIVE`
- `crypto_pwhash_MEMLIMIT_SENSITIVE`

```ts
/**
 * Computes the account recovery key from the mnemonic phrase and orgId.
 * Note: This can take between 15-20 seconds to resolve
 *
 * @param {string} mnemonic - Mnemonic phrase separated by spaces
 * @param {string} orgId - The organisation uuid4
 * @returns {Promise<Uint8Array>} - 64 byte account seed
 */
export const organisationSeed = async (
  mnemonic: string,
  orgId: string
): Promise<Uint8Array> => {
  await _sodium.ready
  const sodium = _sodium

  const OPSLIMIT = sodium.crypto_pwhash_OPSLIMIT_SENSITIVE
  const MEMLIMIT = sodium.crypto_pwhash_MEMLIMIT_SENSITIVE
  const ALG = sodium.crypto_pwhash_ALG_ARGON2ID13

  const seedInput = mnemonic.split(' ').join('-')
  const salt = await saltFromString(orgId)

  const seed = sodium.crypto_pwhash(
    32,
    seedInput,
    salt as Uint8Array,
    OPSLIMIT,
    MEMLIMIT,
    ALG
  )
  return seed
}
```

### 3. Account Keys

Account Keys are used to secure Account and App data, and validate your identity when logging in to a new device.

The **Account Seed** is passed to [libsodium](https://doc.libsodium.org/key_derivation#deriving-keys-from-a-single-high-entropy-key)'s `crypto_kdf_derive_from_key()`
with a unique `ctx` (context) and `subkey_id` to create the two following 256 bit **Account Keys** from a single high entropy seed:

- **_Symmetric Key_**: Used to encrypt all sensitive account data / keys in the Phase Console client. eg. [App seed](/security/phase-encryption#app-keys-and-secret-generation)
- **_Signing Key Seed_**: Is used to generate an [`Ed25519`](https://www.cryptopp.com/wiki/Ed25519) key pair that's used to sign challenges.
  A public key known as the **Account Identity Key** is generated from the **_Signing Key Seed_** using the `crypto_sign_seed_keypair()` in libsodium.
  This public key is stored on the Phase Console backend to cryptographically validate an Account Recovery phrase while trying to log into a new device.
  (In the future this key can also be used to securely share data from one user to another using `X25519`)

```ts
/**
 * Returns the organisation keyring, derived from the hardened seed
 *
 * @param {Uint8Array} seed - Account hardened seed
 * @returns {Promise<OrganisationKeyring>} Account keyring
 */
export const organisationKeyring = async (
  seed: Uint8Array
): Promise<OrganisationKeyring> => {
  await _sodium.ready
  const sodium = _sodium

  const SYMMETRIC_KEY_ID = 0
  const SYMMETRIC_KEY_CONTEXT = '_secret_'

  const SIGNING_KEY_ID = 1
  const SIGNING_KEY_CONTEXT = '__sign__'

  const symmetricKey = sodium.crypto_kdf_derive_from_key(
    32,
    SYMMETRIC_KEY_ID,
    SYMMETRIC_KEY_CONTEXT,
    seed
  )

  const signingKeySeed = sodium.crypto_kdf_derive_from_key(
    32,
    SIGNING_KEY_ID,
    SIGNING_KEY_CONTEXT,
    seed
  )

  const signingKey = sodium.crypto_sign_seed_keypair(signingKeySeed)

  return {
    symmetricKey: sodium.to_hex(symmetricKey),
    privateKey: sodium.to_hex(signingKey.privateKey),
    publicKey: sodium.to_hex(signingKey.publicKey),
  } as OrganisationKeyring
}
```

### 4. Device Vault Key

The Device Vault Key is derived from a user-supplied password, and is used to encrypt the Account Keyring in your browser.

It is derived by hashing a user-supplied local device password known as the `sudo` password with [`Argon2ID`](https://en.wikipedia.org/wiki/Argon2) with the following parameters:

- `crypto_pwhash_OPSLIMIT_MODERATE`
- `crypto_pwhash_MEMLIMIT_MODERATE`

The Account Keyring is encrypted and decrypted with the Device Vault Key using [`XChaCha-Poly1305`](https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305)

```ts
export const deviceVaultKey = async (
  password: string,
  email: string
): Promise<string> => {
  await _sodium.ready
  const sodium = _sodium

  const OPSLIMIT = sodium.crypto_pwhash_OPSLIMIT_MODERATE
  const MEMLIMIT = sodium.crypto_pwhash_MEMLIMIT_MODERATE
  const ALG = sodium.crypto_pwhash_ALG_ARGON2ID13

  const salt = await saltFromString(email)

  const key = sodium.crypto_pwhash(32, password, salt, OPSLIMIT, MEMLIMIT, ALG)
  return sodium.to_hex(key)
}
```

---

## App keys

App keys are used by the [Phase SDKs](/sdks) to encrypt and decrypt data in your applications. App keys are generated as follows:

### 1. App Seed

A random high entropy 32 byte / 256 bit seed is generated using libsodium's `crypto_kdf_keygen()`.
For storage, the App Seed is Encrypted with [`XChaCha-Poly1305`](https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305) using the Account Keyring's symmetric key.
The encrypted seed is stored on the Phase Console backend.

```ts
/**
 * Create a random seed for a new app
 *
 * @returns {Promise<string>} - hex encoded app seed
 */
export const newAppSeed = async () => {
  await _sodium.ready
  const sodium = _sodium

  const seed = sodium.crypto_kdf_keygen()
  return sodium.to_hex(seed)
}
```

### 2. Key derivation from seed

The seed is passed to `crypto_kx_seed_keypair()` which returns an `Ed25519` public / private keypair.

```ts
/**
 * Derives an app keyring from the given seed
 *
 * @param {string} appSeed - App seed as a hex string
 * @returns {Promise<AppKeyring>}
 */
export const appKeyring = async (appSeed: string): Promise<AppKeyring> => {
  await _sodium.ready
  const sodium = _sodium

  const seedBytes = sodium.from_hex(appSeed)
  const appKeypair = sodium.crypto_kx_seed_keypair(seedBytes)

  const { publicKey, privateKey } = appKeypair

  return {
    publicKey: sodium.to_hex(publicKey),
    privateKey: sodium.to_hex(privateKey),
  }
}
```

### 3. App Token

A random high entropy 32 byte / 256 bit token generated by libsodium's `crypto_kdf_keygen()`.
This token is used to by Phase SDKs to authenticate with Phase KMS services.

The App Token is sent as an `Authorization` header to the Phase KMS in the format `Bearer <app_token>`. The App Token is unique for a given `APP_SECRET`. When the `APP_SECRET` is rotated, a new App token is generated.

```ts
/**
 * Create a random token for a new app
 *
 * @returns {Promise<string>} - hex encoded app token
 */
export const newAppToken = async () => {
  await _sodium.ready
  const sodium = _sodium

  const token = sodium.crypto_kdf_keygen()
  return sodium.to_hex(token)
}
```

### 4. Wrapping Key

A random high entropy 32 byte / 256 bit key generated by libsodium's `crypto_kdf_keygen()`. Used to wrap / unwrap **App Share1** with [`XChaCha-Poly1305`](https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305) encryption.

```ts
/**
 * Create a wrapping key for new app
 *
 * @returns {Promise<string>} - hex encoded wrapping key
 */
export const newAppWrapKey = async () => {
  await _sodium.ready
  const sodium = _sodium

  const key = sodium.crypto_kdf_keygen()
  return sodium.to_hex(key)
}
```

### 5. App Key Shares

The private key returned by `crypto_kx_seed_keypair()` is split into two shares, `App Share0` & `App Share1` via a threshold XOR based [secret sharing](/security/cryptography#secret-sharing) scheme.
`Share0` is a random high entropy 32 byte / 256 bit offset key generated via libsodium's `randombytes_buf()`.
`Share1` is computed by computing the XOR of the App private key and the offset key.

```ts
/**
 * Computes a set of shares that can be recombined to obtain the given secret
 *
 * @param {Uint8Array} secret The secret to be split
 * @param {number} shares The number of shares to create
 * @returns {string[]} The shares as hex-encoded strings
 */
export const splitSecret = async (secret: string): Promise<string[]> => {
  const NUMSHARES = 2

  await _sodium.ready
  const sodium = _sodium
  const shares: Uint8Array[] = []

  const secretBytes = sodium.from_hex(secret)

  for (let i = 0; i < NUMSHARES - 1; i++) {
    shares.push(sodium.randombytes_buf(secretBytes.length))
  }

  const lastShare = shares.reduce(
    (prev, curr) => xorUint8Arrays(prev, curr),
    secretBytes
  )
  shares.push(lastShare)

  return shares.map((share) => sodium.to_hex(share))
}
```

---

## Key rotation & revocation

### `APP_SECRET` revocation:

- A user can revoke their App keys my deleting an individual key pair or an App in the Phase Console.
  The encrypted `Share0` that is stored on the Phase KMS network will be deleted. This process can take up to 60 seconds.

### `APP_SECRET` rotation:

- A user can choose to rotate their [`APP_SECRET`](/security/phase-encryption#app-secret) if they believe it has been leaked or compromised.
  The Phase Console will create and deploy new [`APP_SECRET`](/security/phase-encryption#app-secret) by rotating **App Token**, **App Shares** and **Wrapping Key**.
- The encrypted `Share0` that is stored on the Phase KMS network will be updated. This process can take up to 60 seconds.

---

## Data encryption (SDKs)

All encryption and decryption operations are performed using [`XChaCha-Poly1305`](https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305).
Each encryption operation uses a unique symmetric key derived using a key-exchange algorithm, and a random nonce.

![](/assets/phase-sdk-crypto.svg)

### Encryption

1. Create an ephemeral `Ed25519` key pair with libsodium's `crypto_kx_keypair()` utility.
2. Create a 256 bit symmetric `sessionKey` via the `X25519` Elliptic Curve Diffie-Hellman key exchange algorithm with the public key from [`APP_ID`](/security/phase-encryption#app-id) and ephemeral key pair.
3. Use the `sessionKey` to encrypt data with libsodium's `crypto_aead_xchacha20poly1305_ietf_encrypt()`.
4. Return Phase encrypted data in the [`ph:`](/security/phase-encryption#phase-encrypted-data) format.

### Decryption

1. Authenticate to the Phase KMS via the **App Token** from the `APP_SECRET` and fetch the encrypted `Share1`.
2. Reconstruct the `Share0` + `Share1` to assemble the App private key.
3. Derive the `sessionKey` via the `X25519` Elliptic Curve Diffie-Hellman key exchange algorithm from the `ephPublicKey` and the App private key.
4. Use the `sessionKey` to decrypt data with libsodium's `crypto_aead_xchacha20poly1305_ietf_decrypt()`.
5. Return plaintext data

---

## Data Structure

<br className="mt-2" />

<Row>
  <Col>

    ## Phase encrypted data {{ tag: 'ENCRYPTED' }}

    <Properties>
      <Property name="ph" type="plaintext">
        Helps identify data encrypted with Phase SDKs
      </Property>
      <Property name="version" type="plaintext">
        Helps identify version of data encrypted with Phase
      </Property>
            <Property name="ephPublicKey" type="hex">
        An ephemeral Ed25519 public key used to derive XChaCha20-Poly1305 shared symmetric key
      </Property>
            <Property name="ciphertext" type="base64">
        XChaCha20-Poly1305 encrytped data
      </Property>
            <Property name="nonce" type="base64">
        A randomly generated 192bit initialization vector
      </Property>
            <Property name="tag" type="plaintext">
        An optional user supplied string
      </Property>

    </Properties>

  </Col>
  <Col sticky>

    ```
    ph:version:ephPublicKey:ciphertext+nonce:tag
    ```

  </Col>
</Row>

<br className="mt-8" />

<Row>
  <Col>

    ## `APP_ID` {{ tag: 'PUBLIC' }}

    <Properties>
      <Property name="phID" type="plaintext">
        Helps identify Phase SDK appID
      </Property>
      <Property name="version" type="plaintext">
        Helps identify Phase SDK appID version
      </Property>
      <Property name="appID" type="hex">
        Ed25519 public application public key
      </Property>

    </Properties>

  </Col>
  <Col sticky>

    ```
    phApp:version:appID
    ```

  </Col>
</Row>

<br className="mt-8" />

<Row>
  <Col>

    ## `APP_SECRET` {{ tag: 'SECRET' }}

    <Properties>
      <Property name="pss" type="plaintext">
        Helps identify Phase SDK secret
      </Property>
      <Property name="version" type="plaintext">
        Helps identify Phase SDK `APP_SECRET` version
      </Property>
      <Property name="appToken" type="hex">
        Used to authenticate to the Phase Key Management Service (KMS)
      </Property>
      <Property name="share0" type="hex">
        Share0 of the application private key
      </Property>
      <Property name="wrapKey" type="hex">
         A 32 bytes symmetric key used to unwrap share1
      </Property>

    </Properties>

  </Col>
  <Col sticky>

    ```
    pss:version:appToken:share0:wrapKey
    ```

  </Col>
</Row>

---

## Key storage

Keys generated / stored locally:

- **Account Identity Key**
- **24 Word Account Recovery Key** <Tag color="emerald">ENCRYPTED</Tag>
- **Symmetric Key** <Tag color="emerald">ENCRYPTED</Tag>
- **Signing Key Seed** <Tag color="emerald">ENCRYPTED</Tag>

Keys stored on the Phase Console backend:

- **Account Identity Key**
- **APP_ID**
- **App Seed** <Tag color="emerald">ENCRYPTED</Tag>
- **Share1** - <Tag color="emerald">ENCRYPTED</Tag>
