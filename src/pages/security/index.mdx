import { Tag } from '@/components/Tag'
import { HeroPattern } from '@/components/HeroPattern'

export const description =
  'An overview of the Phase architecture, threat model, and high-level concepts.'

<HeroPattern />

<Tag variant="small">SECURITY</Tag>

# Security Overview

Phase provides a secure and easy-to-integrate platform for managing application secrets and configurations. Our focus is on strong security, developer experience, and seamless integration to encourage early adoption of security measures.

## Security FAQ:

**What is end-to-end encrypted?**
- Secrets (keys, values) and comments.

**How is it encrypted?**
- Phase uses X25519 with XChaCha20-Poly1305 for encryption.

**When is data not end-to-end encrypted?**
- When server-side (SSE) encryption is enabled. This allows integration with third-party services and access via a REST API.

**How does Phase protect secret 0?**
- Secret 0 is the a token used to access other secrets in a secret manager. Phase uses private-key-sharding to split cryptographic materials into two shards. One shard is stored on the Phase API and must be called during decryption, allowing for key rotations and audit logging.

**Where is Phase Cloud hosted?**
- Frankfurt (eu-central-1) on AWS.

## Security Objectives

- Provide strong, secure by default end-to-end encrypted configuration and secrets management.
- Abstract the underlying complexity of the system away from the user. 
- Ensure no host server or third party can read or modify secrets, even if compromised.
- Implement reliable, standards-based cryptography with proven libraries.
- Protect against real-world threats without complicating user experience.

## Out of Scope
- Compromise of the client's machine.
- Attacker gaining access to runtime memory state and extracting loaded cryptographic key material.
- Misconfiguration or tampering by a user.
- Network-level attacks that do not target Phase's infrastructure.
- Physical security breaches of the client's premises.
- Denial of Service (DoS) attacks that do not impact Phase's infrastructure.
- Social engineering attacks targeting individual users.
- Browser vulnerabilities or exploits.
- Loss or theft of the client's physical devices.
- Usage of insecure communication channels outside of Phase's provided interfaces.

---

## Infrastructure - Third Party Services (Phase Cloud)

### Hosting - Cloudflare

- Reverse proxy
- Cache
- Workers
- Pages
- WAF
- DDoS Protection
- Rate limiting

### Hosting - AWS

- EC2 - Compute
- RDS PostgreSQL - Relational database
- ElastiCache Redis - In-memory database
- SES - Transactional Emails

### Account Recovery

Upon signing up, your account is set up with a cryptographic keyring. You will record a 24-word recovery phrase to recover these keys. This recovery phrase deterministically derives the keys for your Account Keyring:

- **Symmetric Key** - Secures your App keys.
- **Signing Key Pair** - Validates your recovery key during account recovery or new device login.

Store your recovery phrase safely as it is the root source for retrieving your Account Keyring. Recommended actions:

- Write down or print the recovery phrase and store it securely.
- Save it in a password manager or vault.

### The `sudo` Password

During signup, you will set up a `sudo` password. This encrypts your Account keys for local storage in your browser. Enter this password for certain operations, such as creating an App or rotating an `APP_SECRET`, to decrypt your Account Keyring in memory. To log in on a new device, re-enter your recovery key and set up a new `sudo` password.

<div className="not-prose">
  <Button
    href="/security/phase-encryption#phase-console-client-side-key-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

---

## Tokens

### User Token

A user token is generated as follows:
- A random 32-byte wrappingKey is generated.
- The userKxPrivateKey is split into two shares, `s0` and `s1`.
- `s0` is embedded in the token string, along with the wrappingKey and the userKxPublicKey.
- `s1` is encrypted with the wrappingKey and stored on the backend.

The token string has the format:
```bash
pss_user:v<version>:<userKxPublicKey>:<s0>:<wrappingKey>
```

### Service Tokens

Service tokens are used to programmatically access secrets stored in Phase.

- Service tokens are instantiated with a random publicKey/privateKey keypair, a 32-byte `tokenId` as well as a random wrappingKey.
- The token privateKey is split using an xor-based secret sharding algorithm into 2 shares, `s0` and `s1`.
  - `s0` is embedded in the service token string, along with the wrappingKey and the token publicKey.
  - `s1` is encrypted with the wrappingKey, and stored on the backend.
- For each environment that the service token is scoped to, the respective `envSeed` and `envSalt` is encrypted asymmetrically (wrapped) with the service token publicKey. These wrapped `envSeed` and `envSalt` values, called `wrappedSeed` and `wrappedSalt` are stored on the backend, and supplied for use when the service token is used by the CLI or SDKs.
- To decrypt data with the service token:
  - `s1` is decrypted with the wrappingKey.
  - The service token privateKey is reconstructed from `s0` and `s1`.
  - The service token privateKey is then used to "unwrap" or decrypt the wrappedSeed to get the environment envSeed.
  - The environment keys can then be derived from envSeed, and used to decrypt secrets.

The token string has the format:
```bash
pss_service:{version}:{tokenId}:{publicKey}:{s0}:{wrappingKey}
```

<div className="not-prose">
  <Button
    href="/security/phase-encryption#app-keys-and-secret-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

---

## Secret Sharding

The App private key decrypts data. Storing it in plaintext poses security risks. Phase uses a Dual-Key model, splitting the private key into two shares: one in the `APP_SECRET` and the other on the Phase KMS. Each share alone cannot recreate the private key.

During decryption, the Phase SDKs combine the two shares to reconstruct the private key in memory, which is then used to decrypt data. This ensures the private key is never stored in a single location.

<div className="not-prose">
  <Button
    href="/security/phase-encryption#app-keys-and-secret-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

## Lockbox

Phase Lockbox facilitates one-time secret sharing via links. The key generation and sharing process includes the following steps:

1. **Key Generation**: A unique key is generated for each lockbox using key exchange algorithms and Key Derivation Functions (KDF).
2. **URL Fragment**: The secret is shared through a secure URL containing a fragment with the key.
3. **Expiry**: Lockbox links can be set to expire after a certain period.
4. **Views**: The number of times the secret can be viewed can be limited for additional security.

---

## Phase Console Authentication

### OAuth SSO
Phase supports OAuth SSO for authentication, providing seamless and secure integration with various identity providers.

### Cookies
Cookies used in the Phase console have the following security flags:
- HttpOnly
- Secure
- SameSite

### Sudo Password
The sudo password is required for sensitive operations, adding an extra layer of security.

### Recovery
In case of password loss, recovery is possible through the recovery phrase.

<div className="not-prose">
  <Button
    href="/security/phase-encryption#phase-console-client-side-key-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

## Phase Cryptography

### Generic Encryption
All encryption operations are done asymmetrically. Each operation uses an ephemeral keypair in combination with the public key of the 'recipient' or 'target' to create a session key. Encryption is then performed using the XChaCha-Poly1305 algorithm. The ephemeral public key is prepended to the ciphertext, and the corresponding private key is discarded.

### Generic Decryption
All decryption operations are performed asymmetrically. Each operation uses the recipient's private key in combination with the ephemeral public key prepended to the ciphertext to recreate the session key. Decryption is carried out using the XChaCha-Poly1305 algorithm. The session key is derived from the recipient's private key and the ephemeral public key, and once decryption is complete, the session keys are securely wiped from memory.

### Secret Splitting
Phase uses an xor-based secret splitting scheme to split a given secret into 2 or more shares that can each be stored safely without being able to recreate the original secret.

### User Keys
Each Phase user account has a unique set of keys associated with it. Primarily, this consists of an Ed25519 signing key pair, derived deterministically from a high-entropy seed. This signing key pair is also used to derive an X25519 key-exchange keypair for asymmetric encryption operations.

User keys are derived as follows:
- **Mnemonic Phrase**: Derived from BIP39 wordlist (32 bytes of entropy).
- **Account Seed** (64 bytes): Computed as Argon2ID hash with:
  - Input: Mnemonic with spaces replaced by "-" hyphens.
  - Salt: Blake2b hash of organization UUID (16 bytes).

- **Account Keyring**: PublicKey/PrivateKey, SymmetricKey both derived from Account Seed.
  - **PublicKey/PrivateKey Derivation**:
    - SigningKeySeed (32 bytes) derived using libsodium `crypto_kdf_derive_from_key` (Blake2B under the hood) with constants:
      - KEY_ID = 1
      - CONTEXT = __sign__
    - PublicKey/PrivateKey = `crypto_sign_seed_keypair(SigningKeySeed)` (Ed25519).

  - **SymmetricKey Derivation**:
    - `crypto_kdf_derive_from_key` (Blake2B under the hood) with constants:
      - KEY_ID = 0
      - CONTEXT = _secret_

  - **DeviceKey**: Computed as Argon2ID hash with:
    - Input: User "sudo" password.
    - Salt: Blake2b hash of user email (16 bytes).

- **Encrypted Keyring**: AccountKeyring encrypted using XChaChaPoly1305 asymmetrically with DeviceKey.
- **Encrypted Mnemonic**: Mnemonic encrypted user XChaChaPoly1305 asymmetrically with DeviceKey.
- **Key Exchange Keys**: `userKxPublicKey` / `userKxPrivateKey` are derived from PublicKey/PrivateKey using libsodium utils: `crypto_sign_ed25519_pk_to_curve25519` and `crypto_sign_ed25519_sk_to_curve25519` respectively.

### Environment Keys
Each Environment in a Phase App has a unique encryption key pair to allow secrets to be asymmetrically encrypted and decrypted.

Environment keys are derived as follows:
- **EnvSeed**: 32-byte master key from libsodium `crypto_kdf_keygen`.
- **EnvSalt**: 32-byte master key from libsodium `crypto_kdf_keygen` (used for secret key hash which is used for server-side key lookups).
- **EnvToken**: 32-byte master key from libsodium `crypto_kdf_keygen`.
- **EnvKeys**: Derived from EnvSeed using libsodium `crypto_kx_seed_keypair(EnvSeed)` â†’ `envPublicKey` / `envPrivateKey`.

### Secret Encryption / Decryption
- Secret properties key, value, and comment are encrypted asymmetrically with XChaChaPoly1305 using `envPublicKey`.
- Secret properties key, value, and comment are decrypted asymmetrically with XChaChaPoly1305 using `envPrivateKey`.

### Keydigest
To ensure the integrity and authenticity of keys, a key digest mechanism is employed.

### Environment Access Provisioning
**Users**
- Users are granted access to environments cryptographically, by encrypting the environments' `envSeed` and `envSalt` with the user account's `userKxPublicKey` to compute a `wrappedSeed` and `wrappedSalt` respectively. These are stored on the backend as an EnvironmentKey object. These "wrapped" keys are decrypted client-side and then used to decrypt secrets in an environment.


### User Tokens (PATs)
- User tokens are generated as follows:
  - A random 32-byte wrappingKey is generated.
  - The userKxPrivateKey is split into 2 shares, `s0` and `s1`.
  - `s0` is embedded in the token string, along with the wrappingKey and the userKxPublicKey.
  - `s1` is encrypted with the wrappingKey and stored on the backend.

The token string has the format:
```python
pss_user:{phase_crypto_version}:{userKxPublicKey}:{s0}:{wrappingKey}
```

### Sudo Password:
- **Password Requirements**: Length and complexity constraints to ensure security.
- **KDF**: Argon2ID parameters, input, and salt details for secure password hashing.

<div className="not-prose">
  <Button
    href="/security/phase-encryption#phase-console-client-side-key-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>
