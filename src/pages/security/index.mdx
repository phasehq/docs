import { Tag } from '@/components/Tag'
import { HeroPattern } from '@/components/HeroPattern'

export const description =
  'An overview of the Phase architecture, threat model, and high-level concepts.'

<HeroPattern />

<Tag variant="small">SECURITY</Tag>

# Security Overview

Phase provides a secure and easy-to-integrate platform for managing application secrets and configurations. Our focus is on strong security, developer experience, and seamless integration to encourage early adoption of security measures.

## Security FAQ:

**What is end-to-end encrypted?**
- Secrets (keys, values) and comments.

**How is it encrypted?**
- Phase uses X25519 with XChaCha20-Poly1305 for encryption.

**When is data not end-to-end encrypted?**
- When server-side (SSE) encryption is enabled. This allows integration with third-party services and access via a REST API.

**How does Phase protect secret 0?**
- Secret 0 is the a token used to access other secrets in a secret manager. Phase uses private-key-sharding to split cryptographic materials into two shards. One shard is stored on the Phase API and must be called during decryption, allowing for key rotations and audit logging.

**Where is Phase Cloud hosted?**
- ðŸ‡©ðŸ‡ª Frankfurt (eu-central-1) on AWS.

## Security Objectives

- Provide strong, secure by default end-to-end encrypted configuration and secrets management.
- Abstract the underlying complexity of the system away from the user. 
- Ensure no host server or third party can read or modify secrets, even if compromised.
- Implement reliable, standards-based cryptography with proven libraries.
- Protect against real-world threats without complicating user experience.

## Out of Scope
- Compromise of the client's machine.
- Attacker gaining access to runtime memory state and extracting loaded cryptographic key material.
- Misconfiguration or tampering by a user.
- Network-level attacks that do not target Phase's infrastructure.
- Physical security breaches of the client's premises.
- Denial of Service (DoS) attacks that do not impact Phase's infrastructure.
- Social engineering attacks targeting individual users.
- Browser vulnerabilities or exploits.
- Loss or theft of the client's physical devices.
- Usage of insecure communication channels outside of Phase's provided interfaces.

---

## Infrastructure (Phase Cloud)

### Cloudflare

- Reverse proxy
- Cache
- Workers
- Pages
- WAF
- DDoS Protection
- Rate limiting

### AWS

- EC2 - Compute
- RDS PostgreSQL - Relational database
- ElastiCache Redis - In-memory database
- SES - Transactional Emails

### Account Recovery

During signup, users are provided with a recovery kit that includes their account mnemonic. In the event that a user forgets or misplaces their sudoPassword and cannot decrypt their encryptedKeyring, they can use this recovery kit to recover their account keys and set a new sudoPassword. 

The entered mnemonic is used to repeat the account key derivation process described above, and the user is prompted to set a new sudoPassword. The new encryptedKeyring and encryptedMnemonic are updated on the backend.


- **Symmetric Key** - Secures your App keys.
- **Signing Key Pair** - Validates your recovery key during account recovery or new device login.

Store your recovery phrase safely as it is the root source for retrieving your Account Keyring. Recommended actions:

- Write down or print the recovery phrase and store it securely.
- Save it in a password manager or vault.


<div className="not-prose">
  <Button
    href="/security/phase-encryption#phase-console-client-side-key-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

---

## Tokens

### User Tokens (PATs)

User tokens are are used to programmatically access secrets stored in Phase. They scope of the user token depends on access the user has to apps and the role associated with their account. By default user tokens can be used to access secrets from `0.0.0.0/0` and `::/0`.

- User tokens are generated as follows:
  - A random 32-byte wrappingKey is generated.
  - The userKxPrivateKey is split into 2 shares, `s0` and `s1`.
  - `s0` is embedded in the token string, along with the wrappingKey and the userKxPublicKey.
  - `s1` is encrypted with the wrappingKey and stored on the backend.
- For each environment that the user token has access to, the respective `envSeed` and `envSalt` is encrypted asymmetrically (wrapped) with the user token publicKey. These wrapped `envSeed` and `envSalt` values, called `wrappedSeed` and `wrappedSalt` are stored on the backend, and retrieved for use when the user token is used by the CLI or SDKs.
- To decrypt secrets with the user token:
  - `s1` is decrypted with the wrappingKey.
  - The user token privateKey is reconstructed from `s0` and `s1`.
  - The user token privateKey is then used to "unwrap" or decrypt the wrappedSeed to get the environment envSeed.
  - The environment keys can then be derived from envSeed, and used to decrypt secrets.

The token string has the format:
```bash
pss_user:{version}:{userKxPublicKey}:{s0}:{wrappingKey}
```

### Service Tokens

Service tokens are are used to programmatically access secrets stored in Phase. They can be scoped to a single environment of an application. By default service tokens can be used to access secrets from `0.0.0.0/0` and `::/0`.

- Service tokens are instantiated with a random publicKey/privateKey keypair, a 32-byte `tokenId` as well as a random wrappingKey.
- The token privateKey is split using an xor-based secret sharding algorithm into 2 shares, `s0` and `s1`.
  - `s0` is embedded in the service token string, along with the wrappingKey and the token publicKey.
  - `s1` is encrypted with the wrappingKey, and stored on the backend.
- For each environment that the service token is scoped to, the respective `envSeed` and `envSalt` is encrypted asymmetrically (wrapped) with the service token publicKey. These wrapped `envSeed` and `envSalt` values, called `wrappedSeed` and `wrappedSalt` are stored on the backend, and retrieved for use when the service token is used by the CLI or SDKs.
- To decrypt secrets with the service token:
  - `s1` is decrypted with the wrappingKey.
  - The service token privateKey is reconstructed from `s0` and `s1`.
  - The service token privateKey is then used to "unwrap" or decrypt the wrappedSeed to get the environment envSeed.
  - The environment keys can then be derived from envSeed, and used to decrypt secrets.

The token string has the format:
```bash
pss_service:{version}:{tokenId}:{publicKey}:{s0}:{wrappingKey}
```

<div className="not-prose">
  <Button
    href="/security/phase-encryption#app-keys-and-secret-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

---

## Secret Sharding

The App private key decrypts data. Storing it in plaintext poses security risks. Phase uses a Dual-Key model, splitting the private key into two shares: one in the `APP_SECRET` and the other on the Phase KMS. Each share alone cannot recreate the private key.

During decryption, the Phase SDKs combine the two shares to reconstruct the private key in memory, which is then used to decrypt data. This ensures the private key is never stored in a single location.

<div className="not-prose">
  <Button
    href="/security/phase-encryption#app-keys-and-secret-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

### Keydigest
Secret keys are hashed using Blake2B with the corresponding Environments envSalt as the salt. 
Blake2B(input=key, salt=envSalt, length=32bytes)
These hashes are stored along side each secret on the backend and used for querying secrets via the CLI and SDKs. The required digest can be recomputed by these clients and used to query the backend.

## Lockbox
Lockbox allows secrets to be shared via a single link with a zero-trust encryption scheme. 
To create a new lockbox link with some secret data s:
- A random 32-byte `seed` is generated by libsodium `crypto_kdf_keygen()`
- An X25519 keypair (`boxPublicKey` / `boxPrivateKey`) is derived from the seed by libsodium `crypto_kx_seed_keypair(seed)`
- The secret s is encrypted with the `boxPublicKey` to compute ciphertext `c`, and the boxPrivateKey is discarded
- The ciphertext `c` is stored on the backend along with metadata such as the number of allowed views, link expiry etc and given a unique uuid `boxId`
- The `boxId` and `seed` are used to generate the link: `/lockbox/${boxId}#${seed}`. Note that the `seed` is added as a URL fragment, and thus only parsed by the browser and never sent to the server.
- To retrieve and decrypt a secret shared via Lockbox:
- The `boxId` is used to retrieve the ciphertext `c`
- The `seed` in the link URL fragment is used to compute the keypair (`boxPublicKey` / `boxPrivateKey`) client-side
Ciphertext c is decrypted with the `boxPrivateKey` to get the original secret s

---

## Phase Console Authentication

Users login to the Phase Console via OAuth using one of the available OAuth providers. The OAuth token is validated on the backend, which then issues a session token via an http-only secure cookie. This is used for authenticated requests between the frontend and backend for the remainder of the session.    

<div className="not-prose">
  <Button
    href="/security/phase-encryption#phase-console-client-side-key-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>

## Phase Cryptography

### Encryption
All encryption operations are done asymmetrically. Each operation uses an ephemeral keypair in combination with the public key of the 'recipient' or 'target' to create a session key. Encryption is then performed using the XChaCha-Poly1305 algorithm. The ephemeral public key is prepended to the ciphertext, and the corresponding private key is discarded.

### Decryption
All decryption operations are performed asymmetrically. Each operation uses the recipient's private key in combination with the ephemeral public key prepended to the ciphertext to recreate the session key. Decryption is carried out using the XChaCha-Poly1305 algorithm. The session key is derived from the recipient's private key and the ephemeral public key, and once decryption is complete, the session keys are securely wiped from memory.

### Secret Splitting
Phase uses an xor-based secret splitting scheme to split a given secret into 2 or more shares that can each be stored safely without being able to recreate the original secret.

### User Keys
Each Phase user account has a unique set of keys associated with it. Primarily, this consists of an Ed25519 signing key pair, derived deterministically from a high-entropy seed. This signing key pair is also used to derive an X25519 key-exchange keypair for asymmetric encryption operations.

User keys are derived as follows:
- **Mnemonic Phrase**: Derived from BIP39 wordlist (32 bytes of entropy).
- **Account Seed** (64 bytes): Computed as Argon2ID hash with:
  - Input: Mnemonic with spaces replaced by "-" hyphens.
  - Salt: Blake2b hash of organization UUID (16 bytes).

- **Account Keyring**: PublicKey/PrivateKey, SymmetricKey both derived from Account Seed.
  - **PublicKey/PrivateKey Derivation**:
    - SigningKeySeed (32 bytes) derived using libsodium `crypto_kdf_derive_from_key` (Blake2B under the hood) with constants:
      - KEY_ID = 1
      - CONTEXT = __sign__
    - PublicKey/PrivateKey = `crypto_sign_seed_keypair(SigningKeySeed)` (Ed25519).

  - **SymmetricKey Derivation**:
    - `crypto_kdf_derive_from_key` (Blake2B under the hood) with constants:
      - KEY_ID = 0
      - CONTEXT = _secret_

  - **DeviceKey**: Computed as Argon2ID hash with:
    - Input: User "sudo" password.
    - Salt: Blake2b hash of user email (16 bytes).

- **Encrypted Keyring**: AccountKeyring encrypted using XChaChaPoly1305 asymmetrically with DeviceKey.
- **Encrypted Mnemonic**: Mnemonic encrypted user XChaChaPoly1305 asymmetrically with DeviceKey.
- **Key Exchange Keys**: `userKxPublicKey` / `userKxPrivateKey` are derived from PublicKey/PrivateKey using libsodium utils: `crypto_sign_ed25519_pk_to_curve25519` and `crypto_sign_ed25519_sk_to_curve25519` respectively.

### Environment Keys
Each Environment in a Phase App has a unique encryption key pair to allow secrets to be asymmetrically encrypted and decrypted.

Environment keys are derived as follows:
- **EnvSeed**: 32-byte master key from libsodium `crypto_kdf_keygen`.
- **EnvSalt**: 32-byte master key from libsodium `crypto_kdf_keygen` (used for secret key hash which is used for server-side key lookups).
- **EnvToken**: 32-byte master key from libsodium `crypto_kdf_keygen`.
- **EnvKeys**: Derived from EnvSeed using libsodium `crypto_kx_seed_keypair(EnvSeed)` â†’ `envPublicKey` / `envPrivateKey`.

### Secret Encryption / Decryption
- Secret properties key, value, and comment are encrypted asymmetrically with XChaChaPoly1305 using `envPublicKey`.
- Secret properties key, value, and comment are decrypted asymmetrically with XChaChaPoly1305 using `envPrivateKey`.

### Keydigest
To ensure the integrity and authenticity of keys, a key digest mechanism is employed.

### Environment Access Provisioning
**Users**
- Users are granted access to environments cryptographically, by encrypting the environments' `envSeed` and `envSalt` with the user account's `userKxPublicKey` to compute a `wrappedSeed` and `wrappedSalt` respectively. These are stored on the backend as an EnvironmentKey object. These "wrapped" keys are decrypted client-side and then used to decrypt secrets in an environment.


### Sudo Password:
- **Password Requirements**: Length and complexity constraints to ensure security.
- **KDF**: Argon2ID parameters, input, and salt details for secure password hashing.

<div className="not-prose">
  <Button
    href="/security/phase-encryption#phase-console-client-side-key-generation"
    variant="text"
    arrow="right"
    children="More info"
  />
</div>
