import { Tag } from '@/components/Tag'

export const description =
  'Phase Cryptography is the architecture used to generate encryption keys, secure keys for storage / transmission over the network and perform encryption or decryption operations.'

<Tag variant="small">SECURITY</Tag>

# Phase Cryptography

Phase Cryptography is the end-to-end encryption architecture used to secure secrets, provision access, and handle credentials accross the Phase platform. {{ className: 'lead' }}

Here we describe processes used to generate encryption keys, secure keys for storage and transmission over the network, and perform encryption or decryption operations. {{ className: 'lead' }}
Keys are generated or derived client-side in the Phase Console.

Phase uses [libsodium](https://doc.libsodium.org/) for all primitive crypographic operations including encryption, decryption, signatures, hashing and more. {{ className: 'lead' }}

---

## Encryption

All encryption operations are done asymmetrically. Each operation uses an ephemeral keypair <MathSymbol>(K<sub>eph</sub>, k<sub>eph</sub>)</MathSymbol> in combination with the public key of the 'recipient' or 'target' <MathSymbol>K<sub>recipient</sub></MathSymbol> to derive an X25519 session key <MathSymbol>K<sub>session</sub></MathSymbol>. The plaintext data <MathSymbol>D</MathSymbol> is then encrypted using the XChaCha-Poly1305 algorithm with a random <MathSymbol>IV</MathSymbol> to compute the ciphertext <MathSymbol>C</MathSymbol>. The ephemeral public key <MathSymbol>K<sub>eph</sub></MathSymbol> is prepended to the ciphertext, and the corresponding private key is discarded.

The output of the encryption operation is a string that can be safely stored or transmitted over the network, and contains  <MathSymbol>K<sub>eph</sub> || C || IV</MathSymbol>

![phase encryption](/assets/images/security/phase-encryption.png)

## Decryption

All decryption operations are performed asymmetrically. Each operation uses the recipient's private key <MathSymbol>k<sub>recipient</sub></MathSymbol> in combination with the ephemeral public key <MathSymbol>K<sub>eph</sub></MathSymbol> prepended to the ciphertext to recreate the session key <MathSymbol>K<sub>session</sub></MathSymbol>. Decryption is carried out using the XChaCha-Poly1305 algorithm using the <MathSymbol>IV</MathSymbol> appended to the ciphertext <MathSymbol>C</MathSymbol>. 

![phase decryption](/assets/images/security/phase-decryption.png)

---

## Key Derivation

### User Keys

Each Phase user account has a unique set of keys associated with it. Primarily, this consists of an Ed25519 signing key pair, derived deterministically from a high-entropy seed. This signing key pair is also used to derive an X25519 key-exchange keypair for asymmetric encryption operations.


User keys are derived in two stages. First an *Account Seed* is derived deterministically from a combination of a high-entropy seed and the user's organisation id. Then, the *Account Seed* is used to derive the keypairs for encryption and decryption operations. 

#### **Account Seed Derivation**

When settings up a new Phase account, a random high-entropy 32-byte seed is encoded as a 24-word mnemonic using the BIP39 wordlist. This mnemonic serves as the account recovery phrase. The mnemonic is hashed with Argon2ID with the following parameters:

- Input: Mnemonic with spaces replaced by `-` hyphens.
- Salt: 16-byte Blake2b hash of organization UUID.
- Memory: 1GB
- Iterations: 4

The output of this hash is used as the *Account Seed*.

#### Account Key Derivation from Seed

The *Account Seed* is then used to derive the following keys:


1) **PublicKey/PrivateKey Ed25519 keypair**:
    
A 32 byte Signing Key Seed is derived using libsodium `crypto_kdf_derive_from_key` (implemented using Blake2B) with constants:
  - KEY_ID = `1`
  - CONTEXT = `__sign__`

The Ed25519 Signing Key Pair is then derived from the Signing Key Seed using libsodium `crypto_sign_seed_keypair(SigningKeySeed)`.

2) **Curve25519 Key Exchange Keys** are derived from the Ed25519 PublicKey/PrivateKey pair using libsodium utils `crypto_sign_ed25519_pk_to_curve25519` and `crypto_sign_ed25519_sk_to_curve25519` respectively.

3) A **Symmetric Key** is also derived from the *Account Seed*, although this is currently not used to encrypt or decrypt any data.
This symmetric key is computed used libsodium `crypto_kdf_derive_from_key` with constants:
      - KEY_ID = `0`
      - CONTEXT = `_secret_`

![user key derivation](/assets/images/security/user-key-derivation.png)

#### Device Key and Sudo Password

The account keys derived above are encrypted using a *Device Key* for secure storage on the device as well as the backend. This allows the user keyring to be decrypted by entering a single password, and held in memory for the duration of the session. 

The *Device Key* is computed as a Argon2ID hash with the following parameters:
    - Input: User "sudo" password.
    - Salt: Blake2b hash of user email (16 bytes).
    - Memory: 64MB
    - Iterations: 2

The following data is encrypted using the *Device Key*:

- **Encrypted Keyring**: account keys comprising Signing Key Pair and Symmetric Key.
- **Encrypted Mnemonic**: mnemonic recovery phrase.

![device key derivation](/assets/images/security/device-key.png)


### Environment Keys

Each Environment in a Phase App has a unique encryption key pair to allow secrets to be asymmetrically encrypted and decrypted.

Environment keys are derived as follows:
- **EnvSeed**: 32-byte master key from libsodium `crypto_kdf_keygen`.
- **EnvSalt**: 32-byte master key from libsodium `crypto_kdf_keygen` (used for secret key hash which is used for server-side key lookups).
- **EnvToken**: 32-byte master key from libsodium `crypto_kdf_keygen`.
- **EnvKeys**: Derived from EnvSeed using libsodium `crypto_kx_seed_keypair(EnvSeed)` â†’ `envPublicKey` / `envPrivateKey`.

## Secret Encryption / Decryption

- Secret properties key, value, and comment are encrypted asymmetrically with XChaChaPoly1305 using `envPublicKey`.
- Secret properties key, value, and comment are decrypted asymmetrically with XChaChaPoly1305 using `envPrivateKey`.

### Key digests

Secret keys are hashed client-side using Blake2B with the corresponding Environments' `envSalt` as the salt. 

<MathSymbol>Blake2B(input=key, salt=envSalt, length=32bytes)</MathSymbol>
These hashes are stored along side each secret on the backend and used for querying secrets via the CLI and SDKs. The required digest can be recomputed by these clients and used to query the backend.

## Environment Access Provisioning

**Users**
- Users are granted access to environments cryptographically, by encrypting the environments' `envSeed` and `envSalt` with the user account's `userKxPublicKey` to compute a `wrappedSeed` and `wrappedSalt` respectively. These are stored on the backend as an EnvironmentKey object. These "wrapped" keys are decrypted client-side and then used to decrypt secrets in an environment.

## Lockbox
Lockbox allows secrets to be shared via a single link with a zero-trust encryption scheme. 
To create a new lockbox link with some secret data s:
- A random 32-byte `seed` is generated by libsodium `crypto_kdf_keygen()`
- An X25519 keypair (`boxPublicKey` / `boxPrivateKey`) is derived from the seed by libsodium `crypto_kx_seed_keypair(seed)`
- The secret s is encrypted with the `boxPublicKey` to compute ciphertext `c`, and the boxPrivateKey is discarded
- The ciphertext `c` is stored on the backend along with metadata such as the number of allowed views, link expiry etc and given a unique uuid `boxId`
- The `boxId` and `seed` are used to generate the link: `/lockbox/${boxId}#${seed}`. Note that the `seed` is added as a URL fragment, and thus only parsed by the browser and never sent to the server.
- To retrieve and decrypt a secret shared via Lockbox:
- The `boxId` is used to retrieve the ciphertext `c`
- The `seed` in the link URL fragment is used to compute the keypair (`boxPublicKey` / `boxPrivateKey`) client-side
Ciphertext c is decrypted with the `boxPrivateKey` to get the original secret s


---

## Tokens

### User Tokens (PATs)

User tokens are are used to programmatically access secrets stored in Phase. They scope of the user token depends on access the user has to apps and the role associated with their account. By default user tokens can be used to access secrets from `0.0.0.0/0` and `::/0`.

- User tokens are generated as follows:
  - A random 32-byte wrappingKey is generated.
  - The userKxPrivateKey is split into 2 shares, `s0` and `s1`.
  - `s0` is embedded in the token string, along with the wrappingKey and the userKxPublicKey.
  - `s1` is encrypted with the wrappingKey and stored on the backend.
- For each environment that the user token has access to, the respective `envSeed` and `envSalt` is encrypted asymmetrically (wrapped) with the user token publicKey. These wrapped `envSeed` and `envSalt` values, called `wrappedSeed` and `wrappedSalt` are stored on the backend, and retrieved for use when the user token is used by the CLI or SDKs.
- To decrypt secrets with the user token:
  - `s1` is decrypted with the wrappingKey.
  - The user token privateKey is reconstructed from `s0` and `s1`.
  - The user token privateKey is then used to "unwrap" or decrypt the wrappedSeed to get the environment envSeed.
  - The environment keys can then be derived from envSeed, and used to decrypt secrets.

The token string has the format:
```bash
pss_user:{version}:{userKxPublicKey}:{s0}:{wrappingKey}
```

### Service Tokens

Service tokens are are used to programmatically access secrets stored in Phase. They can be scoped to a single environment of an application. By default service tokens can be used to access secrets from `0.0.0.0/0` and `::/0`.

- Service tokens are instantiated with a random publicKey/privateKey keypair, a 32-byte `tokenId` as well as a random wrappingKey.
- The token privateKey is split using an xor-based secret sharding algorithm into 2 shares, `s0` and `s1`.
  - `s0` is embedded in the service token string, along with the wrappingKey and the token publicKey.
  - `s1` is encrypted with the wrappingKey, and stored on the backend.
- For each environment that the service token is scoped to, the respective `envSeed` and `envSalt` is encrypted asymmetrically (wrapped) with the service token publicKey. These wrapped `envSeed` and `envSalt` values, called `wrappedSeed` and `wrappedSalt` are stored on the backend, and retrieved for use when the service token is used by the CLI or SDKs.
- To decrypt secrets with the service token:
  - `s1` is decrypted with the wrappingKey.
  - The service token privateKey is reconstructed from `s0` and `s1`.
  - The service token privateKey is then used to "unwrap" or decrypt the wrappedSeed to get the environment envSeed.
  - The environment keys can then be derived from envSeed, and used to decrypt secrets.

The token string has the format:
```bash
pss_service:{version}:{tokenId}:{publicKey}:{s0}:{wrappingKey}
```

### Encryption

1. Create an ephemeral `Ed25519` key pair with libsodium's `crypto_kx_keypair()` utility.
2. Create a 256 bit symmetric `sessionKey` via the `X25519` Elliptic Curve Diffie-Hellman key exchange algorithm with the public key from [`APP_ID`](/security/architecture#app-id) and ephemeral key pair.
3. Use the `sessionKey` to encrypt data with libsodium's `crypto_aead_xchacha20poly1305_ietf_encrypt()`.
4. Return Phase encrypted data in the [`ph:`](/security/architecture#phase-encrypted-data) format.

### Decryption

1. Authenticate to the Phase KMS via the **App Token** from the `APP_SECRET` and fetch the encrypted `Share1`.
2. Reconstruct the `Share0` + `Share1` to assemble the App private key.
3. Derive the `sessionKey` via the `X25519` Elliptic Curve Diffie-Hellman key exchange algorithm from the `ephPublicKey` and the App private key.
4. Use the `sessionKey` to decrypt data with libsodium's `crypto_aead_xchacha20poly1305_ietf_decrypt()`.
5. Return plaintext data

---
